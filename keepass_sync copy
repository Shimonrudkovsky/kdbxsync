package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/tobischo/gokeepasslib/v3"
	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/drive/v2"
	"google.golang.org/api/option"
)

func errorCheck(e error, errorMessage string) {
	if e != nil {
		log.Fatalf(errorMessage)
	}
}

func copyFile(src, dst string) (int64, error) {
	sourceFileStat, err := os.Stat(src)
	if err != nil {
		return 0, err
	}

	if !sourceFileStat.Mode().IsRegular() {
		return 0, fmt.Errorf("%s is not a regular file", src)
	}

	source, err := os.Open(src)
	if err != nil {
		return 0, err
	}
	defer source.Close()

	destination, err := os.Create(dst)
	if err != nil {
		return 0, err
	}
	defer destination.Close()
	nBytes, err := io.Copy(destination, source)
	return nBytes, err
}

// Retrieve a token, saves the token, then returns the generated client.
func getClient(config *oauth2.Config) *http.Client {
	// The file token.json stores the user's access and refresh tokens, and is
	// created automatically when the authorization flow completes for the first
	// time.
	tokenFilePath := "token.json"
	token, err := tokenFromFile(tokenFilePath)
	if err != nil {
		token = getTokenFromWeb(config)
		saveToken(tokenFilePath, token)
	}
	return config.Client(context.Background(), token)
}

// Request a token from the web, then returns the retrieved token.
func getTokenFromWeb(config *oauth2.Config) *oauth2.Token {
	authURL := config.AuthCodeURL("state-token", oauth2.AccessTypeOffline)
	fmt.Printf("Go to the following link in your browser then type the "+
		"authorization code: \n%v\n", authURL)

	var authCode string
	_, err := fmt.Scan(&authCode)
	errorCheck(err, "Unable to read authorization code %v")

	token, err := config.Exchange(context.TODO(), authCode)
	errorCheck(err, "Unable to retrieve token from web %v")

	return token
}

// Retrieves a token from a local file.
func tokenFromFile(file string) (*oauth2.Token, error) {
	fileObj, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	defer fileObj.Close()
	token := &oauth2.Token{}
	err = json.NewDecoder(fileObj).Decode(token)
	return token, err
}

// Saves a token to a file path.
func saveToken(path string, token *oauth2.Token) {
	fmt.Printf("Saving credential file to: %s\n", path)
	fileObj, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("Unable to cache oauth token: %v", err)
	}
	defer fileObj.Close()
	json.NewEncoder(fileObj).Encode(token)
}

type Controller struct {
	service *drive.Service
}

func (cntrlr *Controller) uploadFile(filePath string, fileName string) (*drive.File, error) {
	fileObj, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer fileObj.Close()

	fileMeta := &drive.File{Title: fileName}

	resp, err := cntrlr.service.Files.Insert(fileMeta).Media(fileObj).Do()
	if err != nil {
		return nil, err
	}

	return resp, nil
}

func main() {
	log.SetPrefix("### ")
	ctx := context.Background()
	credentialsData, err := os.ReadFile("client_credentials.json")
	errorCheck(err, "Unable to read client secret file: %v")

	//If modifying these scopes, delete your previously saved token.json.
	config, err := google.ConfigFromJSON(credentialsData, drive.DriveScope)
	errorCheck(err, "Unable to parse client secret file to config: %v")
	client := getClient(config)

	srv, err := drive.NewService(ctx, option.WithHTTPClient(client))
	if err != nil {
		log.Fatalf("Unable to retrieve Drive client: %v", err)
	}

	controller := Controller{
		service: srv,
	}

	keepassDatabasePath := "/Users/semen-rudkovskiy/Passwords.kdbx"
	fileName := "Passwords.kdbx"
	// baseMimeType := "text/plain"

	gdFileListResp, err := controller.service.Files.List().Do()
	errorCheck(err, "Unable to get a list of files: %v")
	if len(gdFileListResp.Items) == 0 {
		log.Fatalln("No files found")
	}

	fileObj, err := os.Open(keepassDatabasePath)
	if err != nil {
		log.Fatalln("No keepass database file")
	}
	defer fileObj.Close()

	////////////
	db := gokeepasslib.NewDatabase()
	db.Credentials = gokeepasslib.NewPasswordCredentials("20Msvsvkkkkpcdseioks")
	err = gokeepasslib.NewDecoder(fileObj).Decode(db)
	errorCheck(err, fmt.Sprintf("Decode error: %s", err))

	db.UnlockProtectedEntries()
	defer db.LockProtectedEntries()

	entry := db.Content.Root.Groups[0].Groups[0].Entries[0]
	s, _ := json.MarshalIndent(entry, "", "\t")
	fmt.Println(string(s))

	for _, e := range db.Content.Root.Groups[0].Groups[0].Entries {
		fmt.Printf("%s: %v\n", e.GetTitle(), e.UUID)
	}

	/////////
	return

	fileStat, err := fileObj.Stat()
	errorCheck(err, fmt.Sprintf("Error getting file info: %v", err))

	for _, gdItem := range gdFileListResp.Items {
		if gdItem.Title == fileName && !gdItem.Labels.Trashed {
			timeLayout := "2006-01-02T15:04:05.000Z"
			// srv.Files.Trash(item.Id).Do()
			gdItemParsedModTime, err := time.Parse(timeLayout, gdItem.ModifiedDate)
			errorCheck(err, fmt.Sprintf("Time parse error: %v", err))
			gdItemCreatedDate, err := time.Parse(timeLayout, gdItem.CreatedDate)
			errorCheck(err, fmt.Sprintf("Time parse error: %v", err))
			fileStatModTime := fileStat.ModTime().UTC()

			// s, _ := json.MarshalIndent(gdItem, "", "\t")
			// fmt.Println(string(s))

			fmt.Println(fileStatModTime)
			fmt.Println(gdItem.CreatedDate)
			fmt.Println(gdItemCreatedDate)
			fmt.Println(gdItemParsedModTime.Equal(gdItemCreatedDate))
			fmt.Println(fileStatModTime.After(gdItemCreatedDate))
			fmt.Println(fileStatModTime.Before(gdItemCreatedDate))

			if gdItemParsedModTime.Equal(gdItemCreatedDate) {
				if fileStatModTime.After(gdItemCreatedDate) {
					// local file is modified cloud file is not
					// upload

					// srv.Files.Trash(gdItem.Id).Do()
					// resp, err := controller.uploadFile(keepassDatabasePath, fileName)
					// errorCheck(err, "Upload error: %v")
					// log.Printf("%s\n", resp.Id)
					log.Println("upload")
				} else {
					// neither of this files is modified
					// sync

					log.Println("Need to think")
					i, err := copyFile(keepassDatabasePath, "/Users/semen-rudkovskiy/Passwords-old.kdbx")
					errorCheck(err, fmt.Sprintf("Copy file error: %v", err))
					log.Println(i)
				}
			} else {
				if fileStatModTime.Before(gdItemCreatedDate) {
					// local file is unchanged cloud file is
					// download

					log.Println("download")
					_, err := copyFile(keepassDatabasePath, "/Users/semen-rudkovskiy/Passwords-old.kdbx")
					errorCheck(err, fmt.Sprintf("Copy file error: %v", err))
					copyFile(keepassDatabasePath, keepassDatabasePath+"-old")
				} else {
					// both files are changed
					// sync

					log.Fatalln("Need to sync")
				}
			}
		}
	}

	// resp, err := controller.uploadFile(keepassDatabasePath, fileName)
	// errorCheck(err, "Upload error: %v")

	// log.Printf("%s\n", resp.Id)
}
